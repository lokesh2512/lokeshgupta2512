"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable dot-notation */
const AuthenticationError_1 = require("../auth/AuthenticationError");
const event_1 = require("../event/");
const WebSocketClient_1 = require("./WebSocketClient");
const accessTokenPayload = {
    access_token: 'iJCRCjc8oROO-dkrkqCXOade997oa8Jhbz6awMUQPBQo80VenWqp_oNvfY6AnU5BxEsdDPOBfBP-uz_b0gAKBQ==.v=1.k=1.d=1498600993.t=a.l=.u=aaf9a833-ef30-4c22-86a0-9adc8a15b3b4.c=15037015562284012115',
    expires_in: 900,
    token_type: 'Bearer',
    user: 'aaf9a833-ef30-4c22-86a0-9adc8a15b3b4',
};
const fakeHttpClient = {
    accessTokenStore: {
        accessToken: accessTokenPayload,
    },
    refreshAccessToken: () => Promise.resolve(accessTokenPayload),
};
const invalidTokenHttpClient = {
    accessTokenStore: {
        accessToken: accessTokenPayload,
    },
    refreshAccessToken: () => Promise.reject(new AuthenticationError_1.InvalidTokenError('Invalid token')),
};
const fakeSocket = {
    onclose: () => { },
    onerror: (error) => { },
    onmessage: ({}) => { },
    onopen: () => { },
};
describe('WebSocketClient', () => {
    describe('handler', () => {
        it('calls "onOpen" when WebSocket opens', () => __awaiter(void 0, void 0, void 0, function* () {
            const websocketClient = new WebSocketClient_1.WebSocketClient('url', fakeHttpClient);
            const onOpenSpy = spyOn(websocketClient, 'onOpen').and.callThrough();
            const socket = websocketClient['socket'];
            spyOn(socket, 'getReconnectingWebsocket').and.returnValue(fakeSocket);
            yield websocketClient.connect();
            fakeSocket.onopen();
            expect(onOpenSpy.calls.count()).toBe(1);
        }));
        it('calls "onClose" when WebSocket closes', () => __awaiter(void 0, void 0, void 0, function* () {
            const websocketClient = new WebSocketClient_1.WebSocketClient('url', fakeHttpClient);
            const onCloseSpy = spyOn(websocketClient, 'onClose').and.callThrough();
            const socket = websocketClient['socket'];
            spyOn(socket, 'getReconnectingWebsocket').and.returnValue(fakeSocket);
            yield websocketClient.connect();
            fakeSocket.onclose();
            expect(onCloseSpy.calls.count()).toBe(1);
        }));
        it('calls "onError" when WebSocket received error', () => __awaiter(void 0, void 0, void 0, function* () {
            const websocketClient = new WebSocketClient_1.WebSocketClient('url', fakeHttpClient);
            const onErrorSpy = spyOn(websocketClient, 'onError').and.callThrough();
            const refreshTokenSpy = spyOn(websocketClient, 'refreshAccessToken').and.callThrough();
            const socket = websocketClient['socket'];
            spyOn(socket, 'getReconnectingWebsocket').and.returnValue(fakeSocket);
            yield websocketClient.connect();
            fakeSocket.onerror(new Error('error'));
            expect(onErrorSpy.calls.count()).toBe(1);
            expect(refreshTokenSpy.calls.count()).toBe(1);
        }));
        it('calls "onMessage" when WebSocket received message', () => __awaiter(void 0, void 0, void 0, function* () {
            const message = 'hello';
            const websocketClient = new WebSocketClient_1.WebSocketClient('url', fakeHttpClient);
            const onMessageSpy = spyOn(websocketClient, 'onMessage').and.callThrough();
            const socket = websocketClient['socket'];
            spyOn(socket, 'getReconnectingWebsocket').and.returnValue(fakeSocket);
            yield websocketClient.connect();
            fakeSocket.onmessage({ data: Buffer.from(JSON.stringify({ message }), 'utf-8') });
            expect(onMessageSpy.calls.count()).toBe(1);
        }));
        it('calls "onBeforeConnect" when "onReconnect" is called', () => __awaiter(void 0, void 0, void 0, function* () {
            const onBeforeConnectResult = jasmine.createSpy().and.returnValue(Promise.resolve());
            const onBeforeConnect = () => {
                expect(websocketClient.isLocked()).toBe(true);
                return onBeforeConnectResult();
            };
            const websocketClient = new WebSocketClient_1.WebSocketClient('url', fakeHttpClient);
            const socket = websocketClient['socket'];
            spyOn(socket, 'getReconnectingWebsocket').and.returnValue(fakeSocket);
            yield websocketClient.connect(undefined, onBeforeConnect);
            expect(websocketClient.isLocked()).toBe(false);
            yield websocketClient['onReconnect']();
            expect(onBeforeConnectResult.calls.count()).toBe(1);
            expect(websocketClient.isLocked()).toBe(false);
        }));
        it('emits error when "onBeforeConnect" fails during "onReconnect"', () => __awaiter(void 0, void 0, void 0, function* () {
            const testError = new Error('oh no!');
            let errorHandlerCalled = false;
            const onBeforeConnectResult = jasmine.createSpy().and.returnValue(Promise.reject(testError));
            const onBeforeConnect = () => {
                expect(websocketClient.isLocked()).toBe(true);
                return onBeforeConnectResult();
            };
            const websocketClient = new WebSocketClient_1.WebSocketClient('url', fakeHttpClient);
            const socket = websocketClient['socket'];
            spyOn(socket, 'getReconnectingWebsocket').and.returnValue(fakeSocket);
            websocketClient.on(WebSocketClient_1.WebSocketClient.TOPIC.ON_ERROR, error => {
                expect(onBeforeConnectResult.calls.count()).toBe(1);
                expect(error).toBe(testError);
                errorHandlerCalled = true;
            });
            yield websocketClient.connect(undefined, onBeforeConnect);
            expect(websocketClient.isLocked()).toBe(false);
            yield websocketClient['onReconnect']();
            expect(websocketClient.isLocked()).toBe(false);
            expect(errorHandlerCalled).toBe(true);
        }));
    });
    describe('refreshAccessToken', () => {
        it('emits the correct message for invalid tokens', (done) => __awaiter(void 0, void 0, void 0, function* () {
            const websocketClient = new WebSocketClient_1.WebSocketClient('url', invalidTokenHttpClient);
            const socket = websocketClient['socket'];
            spyOn(socket, 'getReconnectingWebsocket').and.returnValue(fakeSocket);
            yield websocketClient.connect();
            websocketClient.on(WebSocketClient_1.WebSocketClient.TOPIC.ON_INVALID_TOKEN, () => done());
            fakeSocket.onerror(new Error('error'));
        }));
    });
    describe('connect', () => {
        const fakeNotification = {
            id: '123',
            payload: [
                {
                    data: {
                        user: 'Bob',
                    },
                    team: '456',
                    time: new Date().toISOString(),
                    type: event_1.TEAM_EVENT.MEMBER_JOIN,
                },
            ],
        };
        it('does not lock websocket by default', (done) => __awaiter(void 0, void 0, void 0, function* () {
            const websocketClient = new WebSocketClient_1.WebSocketClient('url', fakeHttpClient);
            const onMessageSpy = spyOn(websocketClient, 'onMessage').and.callThrough();
            const socket = websocketClient['socket'];
            spyOn(socket, 'getReconnectingWebsocket').and.returnValue(fakeSocket);
            yield websocketClient.connect();
            expect(websocketClient.isLocked()).toBe(false);
            websocketClient.on(WebSocketClient_1.WebSocketClient.TOPIC.ON_MESSAGE, notification => {
                expect(onMessageSpy.calls.count()).toBe(1);
                expect(websocketClient['bufferedMessages'].length).toBe(0);
                expect(notification).toEqual(fakeNotification);
                done();
            });
            fakeSocket.onmessage({ data: Buffer.from(JSON.stringify(fakeNotification), 'utf-8') });
        }));
        it('emits buffered messages when unlocked', (done) => __awaiter(void 0, void 0, void 0, function* () {
            const websocketClient = new WebSocketClient_1.WebSocketClient('url', fakeHttpClient);
            const onMessageSpy = spyOn(websocketClient, 'onMessage').and.callThrough();
            const socket = websocketClient['socket'];
            spyOn(socket, 'getReconnectingWebsocket').and.returnValue(fakeSocket);
            websocketClient.lock();
            yield websocketClient.connect();
            expect(websocketClient.isLocked()).toBe(true);
            fakeSocket.onmessage({ data: Buffer.from(JSON.stringify(fakeNotification), 'utf-8') });
            expect(onMessageSpy.calls.count()).toBe(1);
            expect(websocketClient['bufferedMessages'].length).toBe(1);
            websocketClient.on(WebSocketClient_1.WebSocketClient.TOPIC.ON_MESSAGE, notification => {
                expect(notification).toEqual(notification);
                expect(onMessageSpy.calls.count()).toBe(2);
                done();
            });
            websocketClient.unlock();
        }));
    });
});
//# sourceMappingURL=WebSocketClient.test.node.js.map