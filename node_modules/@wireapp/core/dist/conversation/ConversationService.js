"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const conversation_1 = require("@wireapp/api-client/dist/conversation/");
const data_1 = require("@wireapp/api-client/dist/conversation/data/");
const http_1 = require("@wireapp/api-client/dist/http/");
const bazinga64_1 = require("bazinga64");
const conversation_2 = require("../conversation/");
const protocol_messaging_1 = require("@wireapp/protocol-messaging");
const AssetCryptography = __importStar(require("../cryptography/AssetCryptography.node"));
const MessageBuilder_1 = require("./message/MessageBuilder");
class ConversationService {
    constructor(apiClient, cryptographyService, assetService) {
        this.apiClient = apiClient;
        this.cryptographyService = cryptographyService;
        this.assetService = assetService;
        this.messageTimer = new conversation_2.MessageTimer();
        this.messageBuilder = new MessageBuilder_1.MessageBuilder(this.apiClient, this.assetService);
    }
    createEphemeral(originalGenericMessage, expireAfterMillis) {
        const ephemeralMessage = protocol_messaging_1.Ephemeral.create({
            expireAfterMillis,
            [originalGenericMessage.content]: originalGenericMessage[originalGenericMessage.content],
        });
        const genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.EPHEMERAL]: ephemeralMessage,
            messageId: originalGenericMessage.messageId,
        });
        return genericMessage;
    }
    getPreKeyBundle(conversationId, userIds, skipOwnClients = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const conversation = yield this.apiClient.conversation.api.getConversation(conversationId);
            const members = ((_a = userIds) === null || _a === void 0 ? void 0 : _a.length) ? userIds.map(id => ({ id })) : conversation.members.others;
            const preKeys = yield Promise.all(members.map(member => this.apiClient.user.api.getUserPreKeys(member.id)));
            if (!skipOwnClients) {
                const selfPreKey = yield this.apiClient.user.api.getUserPreKeys(conversation.members.self.id);
                preKeys.push(selfPreKey);
            }
            return preKeys.reduce((bundleMap, bundle) => {
                bundleMap[bundle.user] = {};
                for (const client of bundle.clients) {
                    bundleMap[bundle.user][client.client] = client.prekey;
                }
                return bundleMap;
            }, {});
        });
    }
    getSelfConversation() {
        const { userId } = this.apiClient.context;
        return this.apiClient.conversation.api.getConversation(userId);
    }
    sendExternalGenericMessage(sendingClientId, conversationId, asset, preKeyBundles) {
        return __awaiter(this, void 0, void 0, function* () {
            const { cipherText, keyBytes, sha256 } = asset;
            const messageId = MessageBuilder_1.MessageBuilder.createId();
            const externalMessage = {
                otrKey: new Uint8Array(keyBytes),
                sha256: new Uint8Array(sha256),
            };
            const base64CipherText = bazinga64_1.Encoder.toBase64(cipherText).asString;
            const genericMessage = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.EXTERNAL]: externalMessage,
                messageId,
            });
            const plainTextArray = protocol_messaging_1.GenericMessage.encode(genericMessage).finish();
            const recipients = yield this.cryptographyService.encrypt(plainTextArray, preKeyBundles);
            return this.sendOTRMessage(sendingClientId, conversationId, recipients, plainTextArray, base64CipherText);
        });
    }
    sendGenericMessage(sendingClientId, conversationId, genericMessage, userIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const plainTextArray = protocol_messaging_1.GenericMessage.encode(genericMessage).finish();
            const preKeyBundles = yield this.getPreKeyBundle(conversationId, userIds);
            if (this.shouldSendAsExternal(plainTextArray, preKeyBundles)) {
                const encryptedAsset = yield AssetCryptography.encryptAsset(plainTextArray);
                return this.sendExternalGenericMessage(this.apiClient.validatedClientId, conversationId, encryptedAsset, preKeyBundles);
            }
            const recipients = yield this.cryptographyService.encrypt(plainTextArray, preKeyBundles);
            return this.sendOTRMessage(sendingClientId, conversationId, recipients, plainTextArray);
        });
    }
    // TODO: Move this to a generic "message sending class".
    sendOTRMessage(sendingClientId, conversationId, recipients, plainTextArray, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = {
                data,
                recipients,
                sender: sendingClientId,
            };
            try {
                yield this.apiClient.conversation.api.postOTRMessage(sendingClientId, conversationId, message);
            }
            catch (error) {
                const reEncryptedMessage = yield this.onClientMismatch(error, message, plainTextArray);
                yield this.apiClient.conversation.api.postOTRMessage(sendingClientId, conversationId, reEncryptedMessage);
            }
        });
    }
    // TODO: Move this to a generic "message sending class" and make it private.
    onClientMismatch(error, message, plainTextArray) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === http_1.StatusCode.PRECONDITION_FAILED) {
                const { missing, deleted } = error.response.data;
                const deletedUserIds = Object.keys(deleted);
                const missingUserIds = Object.keys(missing);
                if (deletedUserIds.length) {
                    for (const deletedUserId of deletedUserIds) {
                        for (const deletedClientId of deleted[deletedUserId]) {
                            const deletedUser = message.recipients[deletedUserId];
                            if (deletedUser) {
                                delete deletedUser[deletedClientId];
                            }
                        }
                    }
                }
                if (missingUserIds.length) {
                    const missingPreKeyBundles = yield this.apiClient.user.api.postMultiPreKeyBundles(missing);
                    const reEncryptedPayloads = yield this.cryptographyService.encrypt(plainTextArray, missingPreKeyBundles);
                    for (const missingUserId of missingUserIds) {
                        for (const missingClientId in reEncryptedPayloads[missingUserId]) {
                            const missingUser = message.recipients[missingUserId];
                            if (!missingUser) {
                                message.recipients[missingUserId] = {};
                            }
                            message.recipients[missingUserId][missingClientId] = reEncryptedPayloads[missingUserId][missingClientId];
                        }
                    }
                }
                return message;
            }
            throw error;
        });
    }
    sendConfirmation(payloadBundle, userIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const { firstMessageId, moreMessageIds, type } = payloadBundle.content;
            const confirmationMessage = protocol_messaging_1.Confirmation.create({
                firstMessageId,
                moreMessageIds,
                type,
            });
            const genericMessage = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.CONFIRMATION]: confirmationMessage,
                messageId: payloadBundle.id,
            });
            yield this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds);
            return Object.assign(Object.assign({}, payloadBundle), { messageTimer: 0, state: conversation_2.PayloadBundleState.OUTGOING_SENT });
        });
    }
    sendEditedText(payloadBundle, userIds) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const { expectsReadConfirmation, legalHoldStatus, linkPreviews, mentions, originalMessageId, quote, text, } = payloadBundle.content;
            const textMessage = protocol_messaging_1.Text.create({
                content: text,
                expectsReadConfirmation,
                legalHoldStatus,
            });
            if ((_a = linkPreviews) === null || _a === void 0 ? void 0 : _a.length) {
                textMessage.linkPreview = this.buildLinkPreviews(linkPreviews);
            }
            if ((_b = mentions) === null || _b === void 0 ? void 0 : _b.length) {
                textMessage.mentions = mentions.map(mention => protocol_messaging_1.Mention.create(mention));
            }
            if (quote) {
                textMessage.quote = protocol_messaging_1.Quote.create({
                    quotedMessageId: quote.quotedMessageId,
                    quotedMessageSha256: quote.quotedMessageSha256,
                });
            }
            const editedMessage = protocol_messaging_1.MessageEdit.create({
                replacingMessageId: originalMessageId,
                text: textMessage,
            });
            const genericMessage = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.EDITED]: editedMessage,
                messageId: payloadBundle.id,
            });
            yield this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds);
            return Object.assign(Object.assign({}, payloadBundle), { messageTimer: 0, state: conversation_2.PayloadBundleState.OUTGOING_SENT });
        });
    }
    sendFileData(payloadBundle, userIds) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!payloadBundle.content) {
                throw new Error('No content for sendFileData provided.');
            }
            const { asset, expectsReadConfirmation, legalHoldStatus } = payloadBundle.content;
            const remoteData = protocol_messaging_1.Asset.RemoteData.create({
                assetId: asset.key,
                assetToken: asset.token,
                otrKey: asset.keyBytes,
                sha256: asset.sha256,
            });
            const assetMessage = protocol_messaging_1.Asset.create({
                expectsReadConfirmation,
                legalHoldStatus,
                uploaded: remoteData,
            });
            assetMessage.status = conversation_2.AssetTransferState.UPLOADED;
            let genericMessage = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.ASSET]: assetMessage,
                messageId: payloadBundle.id,
            });
            const expireAfterMillis = this.messageTimer.getMessageTimer(payloadBundle.conversation);
            if (expireAfterMillis > 0) {
                genericMessage = this.createEphemeral(genericMessage, expireAfterMillis);
            }
            yield this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds);
            return Object.assign(Object.assign({}, payloadBundle), { messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
        });
    }
    sendFileMetaData(payloadBundle, userIds) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!payloadBundle.content) {
                throw new Error('No content for sendFileMetaData provided.');
            }
            const { expectsReadConfirmation, legalHoldStatus, metaData } = payloadBundle.content;
            const original = protocol_messaging_1.Asset.Original.create({
                audio: metaData.audio,
                mimeType: metaData.type,
                name: metaData.name,
                size: metaData.length,
                video: metaData.video,
            });
            const assetMessage = protocol_messaging_1.Asset.create({
                expectsReadConfirmation,
                legalHoldStatus,
                original,
            });
            let genericMessage = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.ASSET]: assetMessage,
                messageId: payloadBundle.id,
            });
            const expireAfterMillis = this.messageTimer.getMessageTimer(payloadBundle.conversation);
            if (expireAfterMillis > 0) {
                genericMessage = this.createEphemeral(genericMessage, expireAfterMillis);
            }
            yield this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds);
            return Object.assign(Object.assign({}, payloadBundle), { messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
        });
    }
    sendFileAbort(payloadBundle, userIds) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!payloadBundle.content) {
                throw new Error('No content for sendFileAbort provided.');
            }
            const { expectsReadConfirmation, legalHoldStatus, reason } = payloadBundle.content;
            const assetMessage = protocol_messaging_1.Asset.create({
                expectsReadConfirmation,
                legalHoldStatus,
                notUploaded: reason,
            });
            assetMessage.status = conversation_2.AssetTransferState.NOT_UPLOADED;
            let genericMessage = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.ASSET]: assetMessage,
                messageId: payloadBundle.id,
            });
            const expireAfterMillis = this.messageTimer.getMessageTimer(payloadBundle.conversation);
            if (expireAfterMillis > 0) {
                genericMessage = this.createEphemeral(genericMessage, expireAfterMillis);
            }
            yield this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds);
            return Object.assign(Object.assign({}, payloadBundle), { messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
        });
    }
    sendImage(payloadBundle, userIds) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!payloadBundle.content) {
                throw new Error('No content for sendImage provided.');
            }
            const { asset, expectsReadConfirmation, image, legalHoldStatus } = payloadBundle.content;
            const imageMetadata = protocol_messaging_1.Asset.ImageMetaData.create({
                height: image.height,
                width: image.width,
            });
            const original = protocol_messaging_1.Asset.Original.create({
                [conversation_2.GenericMessageType.IMAGE]: imageMetadata,
                mimeType: image.type,
                name: null,
                size: image.data.length,
            });
            const remoteData = protocol_messaging_1.Asset.RemoteData.create({
                assetId: asset.key,
                assetToken: asset.token,
                otrKey: asset.keyBytes,
                sha256: asset.sha256,
            });
            const assetMessage = protocol_messaging_1.Asset.create({
                expectsReadConfirmation,
                legalHoldStatus,
                original,
                uploaded: remoteData,
            });
            assetMessage.status = conversation_2.AssetTransferState.UPLOADED;
            let genericMessage = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.ASSET]: assetMessage,
                messageId: payloadBundle.id,
            });
            const expireAfterMillis = this.messageTimer.getMessageTimer(payloadBundle.conversation);
            if (expireAfterMillis > 0) {
                genericMessage = this.createEphemeral(genericMessage, expireAfterMillis);
            }
            yield this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds);
            return Object.assign(Object.assign({}, payloadBundle), { content: assetMessage, messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
        });
    }
    sendLocation(payloadBundle, userIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const { expectsReadConfirmation, latitude, legalHoldStatus, longitude, name, zoom } = payloadBundle.content;
            const locationMessage = protocol_messaging_1.Location.create({
                expectsReadConfirmation,
                latitude,
                legalHoldStatus,
                longitude,
                name,
                zoom,
            });
            let genericMessage = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.LOCATION]: locationMessage,
                messageId: payloadBundle.id,
            });
            const expireAfterMillis = this.messageTimer.getMessageTimer(payloadBundle.conversation);
            if (expireAfterMillis > 0) {
                genericMessage = this.createEphemeral(genericMessage, expireAfterMillis);
            }
            yield this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds);
            return Object.assign(Object.assign({}, payloadBundle), { messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
        });
    }
    sendPing(payloadBundle, userIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const { expectsReadConfirmation, hotKnock = false, legalHoldStatus } = payloadBundle.content;
            const knockMessage = protocol_messaging_1.Knock.create({
                expectsReadConfirmation,
                hotKnock,
                legalHoldStatus,
            });
            let genericMessage = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.KNOCK]: knockMessage,
                messageId: payloadBundle.id,
            });
            const expireAfterMillis = this.messageTimer.getMessageTimer(payloadBundle.conversation);
            if (expireAfterMillis > 0) {
                genericMessage = this.createEphemeral(genericMessage, expireAfterMillis);
            }
            yield this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds);
            return Object.assign(Object.assign({}, payloadBundle), { conversation: payloadBundle.conversation, messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
        });
    }
    sendReaction(payloadBundle, userIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const { legalHoldStatus, originalMessageId, type } = payloadBundle.content;
            const reaction = protocol_messaging_1.Reaction.create({
                emoji: type,
                legalHoldStatus,
                messageId: originalMessageId,
            });
            const genericMessage = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.REACTION]: reaction,
                messageId: payloadBundle.id,
            });
            yield this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds);
            return Object.assign(Object.assign({}, payloadBundle), { messageTimer: 0, state: conversation_2.PayloadBundleState.OUTGOING_SENT });
        });
    }
    sendSessionReset(payloadBundle, userIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const sessionReset = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.CLIENT_ACTION]: protocol_messaging_1.ClientAction.RESET_SESSION,
                messageId: payloadBundle.id,
            });
            yield this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, sessionReset, userIds);
            return Object.assign(Object.assign({}, payloadBundle), { messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
        });
    }
    sendCall(payloadBundle, userIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const callMessage = protocol_messaging_1.Calling.create({
                content: payloadBundle.content,
            });
            const genericMessage = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.CALLING]: callMessage,
                messageId: payloadBundle.id,
            });
            yield this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds);
            return Object.assign(Object.assign({}, payloadBundle), { messageTimer: 0, state: conversation_2.PayloadBundleState.OUTGOING_SENT });
        });
    }
    sendText(payloadBundle, userIds) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const { expectsReadConfirmation, legalHoldStatus, linkPreviews, mentions, quote, text, } = payloadBundle.content;
            const textMessage = protocol_messaging_1.Text.create({
                content: text,
                expectsReadConfirmation,
                legalHoldStatus,
            });
            if ((_a = linkPreviews) === null || _a === void 0 ? void 0 : _a.length) {
                textMessage.linkPreview = this.buildLinkPreviews(linkPreviews);
            }
            if ((_b = mentions) === null || _b === void 0 ? void 0 : _b.length) {
                textMessage.mentions = mentions.map(mention => protocol_messaging_1.Mention.create(mention));
            }
            if (quote) {
                textMessage.quote = protocol_messaging_1.Quote.create({
                    quotedMessageId: quote.quotedMessageId,
                    quotedMessageSha256: quote.quotedMessageSha256,
                });
            }
            let genericMessage = protocol_messaging_1.GenericMessage.create({
                messageId: payloadBundle.id,
                [conversation_2.GenericMessageType.TEXT]: textMessage,
            });
            const expireAfterMillis = this.messageTimer.getMessageTimer(payloadBundle.conversation);
            if (expireAfterMillis > 0) {
                genericMessage = this.createEphemeral(genericMessage, expireAfterMillis);
            }
            yield this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds);
            return Object.assign(Object.assign({}, payloadBundle), { messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
        });
    }
    clearConversation(conversationId, timestamp = new Date(), messageId = MessageBuilder_1.MessageBuilder.createId()) {
        return __awaiter(this, void 0, void 0, function* () {
            if (timestamp instanceof Date) {
                timestamp = timestamp.getTime();
            }
            const content = {
                clearedTimestamp: timestamp,
                conversationId,
            };
            const clearedMessage = protocol_messaging_1.Cleared.create(content);
            const genericMessage = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.CLEARED]: clearedMessage,
                messageId,
            });
            const { id: selfConversationId } = yield this.getSelfConversation();
            yield this.sendGenericMessage(this.apiClient.validatedClientId, selfConversationId, genericMessage);
            return {
                content,
                conversation: conversationId,
                from: this.apiClient.context.userId,
                id: messageId,
                messageTimer: 0,
                source: conversation_2.PayloadBundleSource.LOCAL,
                state: conversation_2.PayloadBundleState.OUTGOING_SENT,
                timestamp: Date.now(),
                type: conversation_2.PayloadBundleType.CONVERSATION_CLEAR,
            };
        });
    }
    deleteMessageLocal(conversationId, messageIdToHide) {
        return __awaiter(this, void 0, void 0, function* () {
            const messageId = MessageBuilder_1.MessageBuilder.createId();
            const content = protocol_messaging_1.MessageHide.create({
                conversationId,
                messageId: messageIdToHide,
            });
            const genericMessage = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.HIDDEN]: content,
                messageId,
            });
            const { id: selfConversationId } = yield this.getSelfConversation();
            yield this.sendGenericMessage(this.apiClient.validatedClientId, selfConversationId, genericMessage);
            return {
                content,
                conversation: conversationId,
                from: this.apiClient.context.userId,
                id: messageId,
                messageTimer: this.messageTimer.getMessageTimer(conversationId),
                source: conversation_2.PayloadBundleSource.LOCAL,
                state: conversation_2.PayloadBundleState.OUTGOING_SENT,
                timestamp: Date.now(),
                type: conversation_2.PayloadBundleType.MESSAGE_HIDE,
            };
        });
    }
    deleteMessageEveryone(conversationId, messageIdToDelete, userIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const messageId = MessageBuilder_1.MessageBuilder.createId();
            const content = protocol_messaging_1.MessageDelete.create({
                messageId: messageIdToDelete,
            });
            const genericMessage = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.DELETED]: content,
                messageId,
            });
            yield this.sendGenericMessage(this.apiClient.validatedClientId, conversationId, genericMessage, userIds);
            return {
                content,
                conversation: conversationId,
                from: this.apiClient.context.userId,
                id: messageId,
                messageTimer: this.messageTimer.getMessageTimer(conversationId),
                source: conversation_2.PayloadBundleSource.LOCAL,
                state: conversation_2.PayloadBundleState.OUTGOING_SENT,
                timestamp: Date.now(),
                type: conversation_2.PayloadBundleType.MESSAGE_DELETE,
            };
        });
    }
    buildLinkPreviews(linkPreviews) {
        const builtLinkPreviews = [];
        for (const linkPreview of linkPreviews) {
            const linkPreviewMessage = protocol_messaging_1.LinkPreview.create({
                permanentUrl: linkPreview.permanentUrl,
                summary: linkPreview.summary,
                title: linkPreview.title,
                url: linkPreview.url,
                urlOffset: linkPreview.urlOffset,
            });
            if (linkPreview.tweet) {
                linkPreviewMessage.tweet = protocol_messaging_1.Tweet.create({
                    author: linkPreview.tweet.author,
                    username: linkPreview.tweet.username,
                });
            }
            if (linkPreview.imageUploaded) {
                const { asset, image } = linkPreview.imageUploaded;
                const imageMetadata = protocol_messaging_1.Asset.ImageMetaData.create({
                    height: image.height,
                    width: image.width,
                });
                const original = protocol_messaging_1.Asset.Original.create({
                    [conversation_2.GenericMessageType.IMAGE]: imageMetadata,
                    mimeType: image.type,
                    size: image.data.length,
                });
                const remoteData = protocol_messaging_1.Asset.RemoteData.create({
                    assetId: asset.key,
                    assetToken: asset.token,
                    otrKey: asset.keyBytes,
                    sha256: asset.sha256,
                });
                const assetMessage = protocol_messaging_1.Asset.create({
                    original,
                    uploaded: remoteData,
                });
                linkPreviewMessage.image = assetMessage;
            }
            linkPreviewMessage.article = protocol_messaging_1.Article.create({
                image: linkPreviewMessage.image,
                permanentUrl: linkPreviewMessage.permanentUrl,
                summary: linkPreviewMessage.summary,
                title: linkPreviewMessage.title,
            });
            builtLinkPreviews.push(linkPreviewMessage);
        }
        return builtLinkPreviews;
    }
    shouldSendAsExternal(plainText, preKeyBundles) {
        const EXTERNAL_MESSAGE_THRESHOLD_BYTES = 200 * 1024;
        let clientCount = 0;
        for (const user in preKeyBundles) {
            clientCount += Object.keys(preKeyBundles[user]).length;
        }
        const messageInBytes = new Uint8Array(plainText).length;
        const estimatedPayloadInBytes = clientCount * messageInBytes;
        return estimatedPayloadInBytes > EXTERNAL_MESSAGE_THRESHOLD_BYTES;
    }
    leaveConversation(conversationId) {
        return this.apiClient.conversation.api.deleteMember(conversationId, this.apiClient.context.userId);
    }
    leaveConversations(conversationIds) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!conversationIds) {
                const conversation = yield this.getConversations();
                conversationIds = conversation
                    .filter(conversation => conversation.type === conversation_1.CONVERSATION_TYPE.REGULAR)
                    .map(conversation => conversation.id);
            }
            return Promise.all(conversationIds.map(conversationId => this.leaveConversation(conversationId)));
        });
    }
    createConversation(name, otherUserIds = []) {
        const ids = typeof otherUserIds === 'string' ? [otherUserIds] : otherUserIds;
        const newConversation = {
            name,
            users: ids,
        };
        return this.apiClient.conversation.api.postConversation(newConversation);
    }
    getConversations(conversationIds) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!conversationIds || !conversationIds.length) {
                return this.apiClient.conversation.api.getAllConversations();
            }
            if (typeof conversationIds === 'string') {
                return this.apiClient.conversation.api.getConversation(conversationIds);
            }
            return this.apiClient.conversation.api.getConversationsByIds(conversationIds);
        });
    }
    getAsset({ assetId, assetToken, otrKey, sha256 }) {
        return __awaiter(this, void 0, void 0, function* () {
            const encryptedBuffer = yield this.apiClient.asset.api.getAsset(assetId, assetToken);
            return AssetCryptography.decryptAsset({
                cipherText: Buffer.from(encryptedBuffer),
                keyBytes: Buffer.from(otrKey),
                sha256: Buffer.from(sha256),
            });
        });
    }
    getUnencryptedAsset(assetId, assetToken) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiClient.asset.api.getAsset(assetId, assetToken);
        });
    }
    addUser(conversationId, userIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const ids = typeof userIds === 'string' ? [userIds] : userIds;
            yield this.apiClient.conversation.api.postMembers(conversationId, ids);
            return userIds;
        });
    }
    removeUser(conversationId, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.apiClient.conversation.api.deleteMember(conversationId, userId);
            return userId;
        });
    }
    /**
     * @param payloadBundle Outgoing message
     * @param userIds Only send message to specified user IDs
     * @returns Sent message
     */
    send(payloadBundle, userIds) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (payloadBundle.type) {
                case conversation_2.PayloadBundleType.ASSET:
                    return this.sendFileData(payloadBundle, userIds);
                case conversation_2.PayloadBundleType.ASSET_ABORT:
                    return this.sendFileAbort(payloadBundle, userIds);
                case conversation_2.PayloadBundleType.ASSET_META:
                    return this.sendFileMetaData(payloadBundle, userIds);
                case conversation_2.PayloadBundleType.ASSET_IMAGE:
                    return this.sendImage(payloadBundle, userIds);
                case conversation_2.PayloadBundleType.CALL:
                    return this.sendCall(payloadBundle, userIds);
                case conversation_2.PayloadBundleType.CLIENT_ACTION: {
                    if (payloadBundle.content.clientAction === protocol_messaging_1.ClientAction.RESET_SESSION) {
                        return this.sendSessionReset(payloadBundle, userIds);
                    }
                    throw new Error(`No send method implemented for "${payloadBundle.type}" and ClientAction "${payloadBundle.content}".`);
                }
                case conversation_2.PayloadBundleType.CONFIRMATION:
                    return this.sendConfirmation(payloadBundle, userIds);
                case conversation_2.PayloadBundleType.LOCATION:
                    return this.sendLocation(payloadBundle, userIds);
                case conversation_2.PayloadBundleType.MESSAGE_EDIT:
                    return this.sendEditedText(payloadBundle, userIds);
                case conversation_2.PayloadBundleType.PING:
                    return this.sendPing(payloadBundle, userIds);
                case conversation_2.PayloadBundleType.REACTION:
                    return this.sendReaction(payloadBundle, userIds);
                case conversation_2.PayloadBundleType.TEXT:
                    return this.sendText(payloadBundle, userIds);
                default:
                    throw new Error(`No send method implemented for "${payloadBundle['type']}".`);
            }
        });
    }
    sendTypingStart(conversationId) {
        return this.apiClient.conversation.api.postTyping(conversationId, { status: data_1.CONVERSATION_TYPING.STARTED });
    }
    sendTypingStop(conversationId) {
        return this.apiClient.conversation.api.postTyping(conversationId, { status: data_1.CONVERSATION_TYPING.STOPPED });
    }
    setConversationMutedStatus(conversationId, status, muteTimestamp) {
        if (typeof muteTimestamp === 'number') {
            muteTimestamp = new Date(muteTimestamp);
        }
        const payload = {
            otr_muted_ref: muteTimestamp.toISOString(),
            otr_muted_status: status,
        };
        return this.apiClient.conversation.api.putMembershipProperties(conversationId, payload);
    }
    toggleArchiveConversation(conversationId, archived, archiveTimestamp = new Date()) {
        if (typeof archiveTimestamp === 'number') {
            archiveTimestamp = new Date(archiveTimestamp);
        }
        const payload = {
            otr_archived: archived,
            otr_archived_ref: archiveTimestamp.toISOString(),
        };
        return this.apiClient.conversation.api.putMembershipProperties(conversationId, payload);
    }
}
exports.ConversationService = ConversationService;
//# sourceMappingURL=ConversationService.js.map