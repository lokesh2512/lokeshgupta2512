import * as CBOR from '@wireapp/cbor';
import { SessionState } from './SessionState';
import { IdentityKey } from '../keys/IdentityKey';
import { IdentityKeyPair } from '../keys/IdentityKeyPair';
import { PreKeyBundle } from '../keys/PreKeyBundle';
import { PublicKey } from '../keys/PublicKey';
import { Envelope } from '../message/Envelope';
import { SessionTag } from '../message/SessionTag';
import { PreKeyStore } from './PreKeyStore';
export interface IntermediateSessionState {
    [index: string]: {
        idx: number;
        state: SessionState;
        tag: SessionTag;
    };
}
export declare class Session {
    static MAX_RECV_CHAINS: number;
    static MAX_SESSION_STATES: number;
    counter: number;
    local_identity: IdentityKeyPair;
    pending_prekey: (number | PublicKey)[] | null;
    remote_identity: IdentityKey;
    session_states: IntermediateSessionState;
    session_tag: SessionTag;
    version: number;
    constructor();
    /**
     * @param local_identity Alice's Identity Key Pair
     * @param remote_pkbundle Bob's Pre-Key Bundle
     */
    static init_from_prekey(local_identity: IdentityKeyPair, remote_pkbundle: PreKeyBundle): Promise<Session>;
    static init_from_message(our_identity: IdentityKeyPair, prekey_store: PreKeyStore, envelope: Envelope): Promise<[Session, Uint8Array]>;
    private _new_state;
    private _insert_session_state;
    private _evict_oldest_session_state;
    get_local_identity(): IdentityKey;
    /**
     * @param plaintext The plaintext which needs to be encrypted
     */
    encrypt(plaintext: string | Uint8Array): Promise<Envelope>;
    decrypt(prekey_store: PreKeyStore, envelope: Envelope): Promise<Uint8Array>;
    private _decrypt_prekey_message;
    private _decrypt_cipher_message;
    serialise(): ArrayBuffer;
    static deserialise(local_identity: IdentityKeyPair, buf: ArrayBuffer): Session;
    encode(encoder: CBOR.Encoder): void;
    static decode(local_identity: IdentityKeyPair, decoder: CBOR.Decoder): Session;
}
