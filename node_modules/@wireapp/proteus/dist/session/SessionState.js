"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const CBOR = require("@wireapp/cbor");
const ArrayUtil = require("../util/ArrayUtil");
const ClassUtil = require("../util/ClassUtil");
const MemoryUtil = require("../util/MemoryUtil");
const DecryptError_1 = require("../errors/DecryptError");
const DerivedSecrets_1 = require("../derived/DerivedSecrets");
const KeyPair_1 = require("../keys/KeyPair");
const CipherMessage_1 = require("../message/CipherMessage");
const Envelope_1 = require("../message/Envelope");
const PreKeyMessage_1 = require("../message/PreKeyMessage");
const ChainKey_1 = require("./ChainKey");
const RecvChain_1 = require("./RecvChain");
const RootKey_1 = require("./RootKey");
const SendChain_1 = require("./SendChain");
const Session_1 = require("./Session");
class SessionState {
    constructor() {
        this.prev_counter = -1;
        this.recv_chains = [];
        this.root_key = new RootKey_1.RootKey();
        this.send_chain = new SendChain_1.SendChain();
    }
    static init_as_alice(alice_identity_pair, alice_base, bob_pkbundle) {
        return __awaiter(this, void 0, void 0, function* () {
            const master_key = ArrayUtil.concatenate_array_buffers([
                alice_identity_pair.secret_key.shared_secret(bob_pkbundle.public_key),
                alice_base.secret_key.shared_secret(bob_pkbundle.identity_key.public_key),
                alice_base.secret_key.shared_secret(bob_pkbundle.public_key),
            ]);
            const derived_secrets = DerivedSecrets_1.DerivedSecrets.kdf_without_salt(master_key, 'handshake');
            MemoryUtil.zeroize(master_key);
            const rootkey = RootKey_1.RootKey.from_cipher_key(derived_secrets.cipher_key);
            const chainkey = ChainKey_1.ChainKey.from_mac_key(derived_secrets.mac_key, 0);
            const recv_chains = [RecvChain_1.RecvChain.new(chainkey, bob_pkbundle.public_key)];
            const send_ratchet = yield KeyPair_1.KeyPair.new();
            const [rok, chk] = rootkey.dh_ratchet(send_ratchet, bob_pkbundle.public_key);
            const send_chain = SendChain_1.SendChain.new(chk, send_ratchet);
            const state = ClassUtil.new_instance(SessionState);
            state.recv_chains = recv_chains;
            state.send_chain = send_chain;
            state.root_key = rok;
            state.prev_counter = 0;
            return state;
        });
    }
    static init_as_bob(bob_ident, bob_prekey, alice_ident, alice_base) {
        const master_key = ArrayUtil.concatenate_array_buffers([
            bob_prekey.secret_key.shared_secret(alice_ident.public_key),
            bob_ident.secret_key.shared_secret(alice_base),
            bob_prekey.secret_key.shared_secret(alice_base),
        ]);
        const derived_secrets = DerivedSecrets_1.DerivedSecrets.kdf_without_salt(master_key, 'handshake');
        MemoryUtil.zeroize(master_key);
        const rootkey = RootKey_1.RootKey.from_cipher_key(derived_secrets.cipher_key);
        const chainkey = ChainKey_1.ChainKey.from_mac_key(derived_secrets.mac_key, 0);
        const send_chain = SendChain_1.SendChain.new(chainkey, bob_prekey);
        const state = ClassUtil.new_instance(SessionState);
        state.recv_chains = [];
        state.send_chain = send_chain;
        state.root_key = rootkey;
        state.prev_counter = 0;
        return state;
    }
    ratchet(ratchet_key) {
        return __awaiter(this, void 0, void 0, function* () {
            const new_ratchet = yield KeyPair_1.KeyPair.new();
            const [recv_root_key, recv_chain_key] = this.root_key.dh_ratchet(this.send_chain.ratchet_key, ratchet_key);
            const [send_root_key, send_chain_key] = recv_root_key.dh_ratchet(new_ratchet, ratchet_key);
            const recv_chain = RecvChain_1.RecvChain.new(recv_chain_key, ratchet_key);
            const send_chain = SendChain_1.SendChain.new(send_chain_key, new_ratchet);
            this.root_key = send_root_key;
            this.prev_counter = this.send_chain.chain_key.idx;
            this.send_chain = send_chain;
            this.recv_chains.unshift(recv_chain);
            if (this.recv_chains.length > Session_1.Session.MAX_RECV_CHAINS) {
                for (let index = Session_1.Session.MAX_RECV_CHAINS; index < this.recv_chains.length; index++) {
                    MemoryUtil.zeroize(this.recv_chains[index]);
                }
                this.recv_chains = this.recv_chains.slice(0, Session_1.Session.MAX_RECV_CHAINS);
            }
        });
    }
    /**
     * @param identity_key Public identity key of the local identity key pair
     * @param pending Pending pre-key
     * @param tag Session tag
     * @param plaintext The plaintext to encrypt
     */
    encrypt(identity_key, pending, tag, plaintext) {
        const msgkeys = this.send_chain.chain_key.message_keys();
        let message = CipherMessage_1.CipherMessage.new(tag, this.send_chain.chain_key.idx, this.prev_counter, this.send_chain.ratchet_key.public_key, msgkeys.encrypt(plaintext));
        if (pending) {
            message = PreKeyMessage_1.PreKeyMessage.new(pending[0], pending[1], identity_key, message);
        }
        const env = Envelope_1.Envelope.new(msgkeys.mac_key, message);
        this.send_chain.chain_key = this.send_chain.chain_key.next();
        return env;
    }
    decrypt(envelope, msg) {
        return __awaiter(this, void 0, void 0, function* () {
            let idx = this.recv_chains.findIndex(chain => chain.ratchet_key.fingerprint() === msg.ratchet_key.fingerprint());
            if (idx === -1) {
                yield this.ratchet(msg.ratchet_key);
                idx = 0;
            }
            const rc = this.recv_chains[idx];
            if (msg.counter < rc.chain_key.idx) {
                return rc.try_message_keys(envelope, msg);
            }
            else if (msg.counter == rc.chain_key.idx) {
                const mks = rc.chain_key.message_keys();
                if (!envelope.verify(mks.mac_key)) {
                    throw new DecryptError_1.DecryptError.InvalidSignature(`Envelope verification failed for message with counters in sync at '${msg.counter}'. The received message was possibly encrypted for another client.`, DecryptError_1.DecryptError.CODE.CASE_206);
                }
                const plain = mks.decrypt(msg.cipher_text);
                rc.chain_key = rc.chain_key.next();
                return plain;
            }
            const [chk, mk, mks] = rc.stage_message_keys(msg);
            if (!envelope.verify(mk.mac_key)) {
                throw new DecryptError_1.DecryptError.InvalidSignature(`Envelope verification failed for message with counter ahead. Message index is '${msg.counter}' while receive chain index is '${rc.chain_key.idx}'.`, DecryptError_1.DecryptError.CODE.CASE_207);
            }
            const plain = mk.decrypt(msg.cipher_text);
            rc.chain_key = chk.next();
            rc.commit_message_keys(mks);
            return plain;
        });
    }
    serialise() {
        const encoder = new CBOR.Encoder();
        this.encode(encoder);
        return encoder.get_buffer();
    }
    static deserialise(buf) {
        return SessionState.decode(new CBOR.Decoder(buf));
    }
    encode(encoder) {
        encoder.object(4);
        encoder.u8(0);
        encoder.array(this.recv_chains.length);
        this.recv_chains.map(rch => rch.encode(encoder));
        encoder.u8(1);
        this.send_chain.encode(encoder);
        encoder.u8(2);
        this.root_key.encode(encoder);
        encoder.u8(3);
        return encoder.u32(this.prev_counter);
    }
    static decode(decoder) {
        const self = ClassUtil.new_instance(SessionState);
        const nprops = decoder.object();
        for (let index = 0; index <= nprops - 1; index++) {
            switch (decoder.u8()) {
                case 0: {
                    self.recv_chains = [];
                    let len = decoder.array();
                    while (len--) {
                        self.recv_chains.push(RecvChain_1.RecvChain.decode(decoder));
                    }
                    break;
                }
                case 1: {
                    self.send_chain = SendChain_1.SendChain.decode(decoder);
                    break;
                }
                case 2: {
                    self.root_key = RootKey_1.RootKey.decode(decoder);
                    break;
                }
                case 3: {
                    self.prev_counter = decoder.u32();
                    break;
                }
                default: {
                    decoder.skip();
                }
            }
        }
        return self;
    }
}
exports.SessionState = SessionState;
//# sourceMappingURL=SessionState.js.map