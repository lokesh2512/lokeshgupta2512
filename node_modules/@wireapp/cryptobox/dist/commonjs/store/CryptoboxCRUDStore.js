"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const proteus_1 = require("@wireapp/proteus");
const store_engine_1 = require("@wireapp/store-engine");
const bazinga64_1 = require("bazinga64");
const store_1 = require("../store/");
var CRUDStoreKeys;
(function (CRUDStoreKeys) {
    CRUDStoreKeys["LOCAL_IDENTITY"] = "local_identity";
})(CRUDStoreKeys = exports.CRUDStoreKeys || (exports.CRUDStoreKeys = {}));
var CrudStoreStores;
(function (CrudStoreStores) {
    CrudStoreStores["LOCAL_IDENTITY"] = "keys";
    CrudStoreStores["PRE_KEYS"] = "prekeys";
    CrudStoreStores["SESSIONS"] = "sessions";
})(CrudStoreStores = exports.CrudStoreStores || (exports.CrudStoreStores = {}));
class CryptoboxCRUDStore {
    constructor(engine) {
        this.engine = engine;
    }
    from_store(record) {
        return typeof record.serialised === 'string'
            ? bazinga64_1.Decoder.fromBase64(record.serialised).asBytes.buffer
            : record.serialised;
    }
    to_store(serialised) {
        return bazinga64_1.Encoder.toBase64(serialised).asString;
    }
    delete_all() {
        return Promise.resolve()
            .then(() => this.engine.deleteAll(CryptoboxCRUDStore.STORES.LOCAL_IDENTITY))
            .then(() => this.engine.deleteAll(CryptoboxCRUDStore.STORES.PRE_KEYS))
            .then(() => this.engine.deleteAll(CryptoboxCRUDStore.STORES.SESSIONS))
            .then(() => true);
    }
    /**
     * Deletes a specified PreKey.
     * @returns Promise<string> Resolves with the "ID" from the record, which has been deleted.
     */
    delete_prekey(prekey_id) {
        return this.engine.delete(CryptoboxCRUDStore.STORES.PRE_KEYS, prekey_id.toString()).then(() => prekey_id);
    }
    /**
     * Loads the local identity.
     * @returns Promise<ProteusKeys.IdentityKeyPair> Resolves with the "key pair" from the local identity.
     */
    load_identity() {
        return this.engine
            .read(CryptoboxCRUDStore.STORES.LOCAL_IDENTITY, CryptoboxCRUDStore.KEYS.LOCAL_IDENTITY)
            .then(record => {
            const payload = this.from_store(record);
            const identity = proteus_1.keys.IdentityKeyPair.deserialise(payload);
            return identity;
        })
            .catch((error) => {
            if (error instanceof store_engine_1.error.RecordNotFoundError) {
                return undefined;
            }
            throw error;
        });
    }
    /**
     * Loads and deserializes a specified PreKey.
     * @returns Promise<ProteusKeys.PreKey> Resolves with the the specified "PreKey".
     */
    load_prekey(prekey_id) {
        return this.engine
            .read(CryptoboxCRUDStore.STORES.PRE_KEYS, prekey_id.toString())
            .then(record => {
            const payload = this.from_store(record);
            return proteus_1.keys.PreKey.deserialise(payload);
        })
            .catch(error => {
            if (error instanceof store_engine_1.error.RecordNotFoundError) {
                return undefined;
            }
            throw error;
        });
    }
    /**
     * Loads all available PreKeys.
     */
    load_prekeys() {
        return this.engine.readAll(CryptoboxCRUDStore.STORES.PRE_KEYS).then(records => {
            const preKeys = [];
            records.forEach(record => {
                const payload = this.from_store(record);
                const preKey = proteus_1.keys.PreKey.deserialise(payload);
                preKeys.push(preKey);
            });
            return preKeys;
        });
    }
    /**
     * Saves the local identity.
     * @returns Promise<string> Resolves with the "fingerprint" from the saved local identity.
     */
    save_identity(identity) {
        const serialised = this.to_store(identity.serialise());
        const payload = new store_1.SerialisedRecord(serialised, CryptoboxCRUDStore.KEYS.LOCAL_IDENTITY);
        return this.engine.create(CryptoboxCRUDStore.STORES.LOCAL_IDENTITY, payload.id, payload).then(() => identity);
    }
    /**
     * Saves the serialised format of a specified PreKey.
     * @returns Promise<string> Resolves with the "ID" from the saved PreKey record.
     */
    save_prekey(pre_key) {
        const serialised = this.to_store(pre_key.serialise());
        const payload = new store_1.SerialisedRecord(serialised, pre_key.key_id.toString());
        return this.engine.create(CryptoboxCRUDStore.STORES.PRE_KEYS, payload.id, payload).then(() => pre_key);
    }
    /**
     * Saves the serialised formats from a batch of PreKeys.
     */
    save_prekeys(pre_keys) {
        const promises = pre_keys.map(pre_key => this.save_prekey(pre_key));
        return Promise.all(promises).then(() => pre_keys);
    }
    /**
     * Saves a specified session.
     * @returns Promise<ProteusSession.Session> Resolves with the saved session.
     */
    create_session(session_id, session) {
        const serialised = this.to_store(session.serialise());
        const payload = new store_1.SerialisedRecord(serialised, session_id);
        return this.engine.create(CryptoboxCRUDStore.STORES.SESSIONS, payload.id, payload).then(() => session);
    }
    /**
     * Loads a specified session.
     * @returns Promise<ProteusSession.Session> Resolves with the the specified "session".
     */
    read_session(identity, session_id) {
        return this.engine.read(CryptoboxCRUDStore.STORES.SESSIONS, session_id).then(record => {
            const payload = this.from_store(record);
            return proteus_1.session.Session.deserialise(identity, payload);
        });
    }
    read_sessions(identity) {
        return __awaiter(this, void 0, void 0, function* () {
            const sessionIds = yield this.engine.readAllPrimaryKeys(CryptoboxCRUDStore.STORES.SESSIONS);
            const sessions = {};
            for (const sessionId of sessionIds) {
                sessions[sessionId] = yield this.read_session(identity, sessionId);
            }
            return sessions;
        });
    }
    update_session(session_id, session) {
        const serialised = this.to_store(session.serialise());
        const payload = new store_1.SerialisedRecord(serialised, session_id);
        return this.engine
            .update(CryptoboxCRUDStore.STORES.SESSIONS, payload.id, { serialised: payload.serialised })
            .then(() => session);
    }
    /**
     * Deletes a specified session.
     * @returns Promise<string> Resolves with the "ID" from the record, which has been deleted.
     */
    delete_session(session_id) {
        return this.engine
            .delete(CryptoboxCRUDStore.STORES.SESSIONS, session_id)
            .then((primary_key) => primary_key);
    }
}
exports.CryptoboxCRUDStore = CryptoboxCRUDStore;
CryptoboxCRUDStore.KEYS = CRUDStoreKeys;
CryptoboxCRUDStore.STORES = CrudStoreStores;
//# sourceMappingURL=CryptoboxCRUDStore.js.map